%-------------------------designed by zcf--------------
\documentclass[UTF8,a4paper,10pt]{ctexart}
\usepackage[left=3.17cm, right=3.17cm, top=2.74cm, bottom=2.74cm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx,subfig}
\usepackage{float}
\usepackage{cite}
\usepackage{caption}
\usepackage{enumerate}
\usepackage{booktabs} %表格
\usepackage{multirow}
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}  %表格强制换行
%-------------------------字体设置--------------
\usepackage{times} 
\newcommand{\yihao}{\fontsize{30pt}{42pt}\selectfont}           % 一号, 1.4 倍行距
\newcommand{\erhao}{\fontsize{26pt}{36pt}\selectfont}           % 一号, 1.4 倍行距
\newcommand{\xiaoer}{\fontsize{22pt}{28pt}\selectfont}          % 二号, 1.25倍行距
\newcommand{\sanhao}{\fontsize{18pt}{18pt}\selectfont}          % 小二, 单倍行距
\newcommand{\xiaosan}{\fontsize{16pt}{24pt}\selectfont}  %三号字
\newcommand{\sihao}{\fontsize{15pt}{22pt}\selectfont}        % 小三, 1.5倍行距
\newcommand{\banxiaosi}{\fontsize{14pt}{21pt}\selectfont}            % 四号, 1.5 倍行距
\newcommand{\xiaosi}{\fontsize{13pt}{19.5pt}\selectfont}    % 半小四, 1.5倍行距
\newcommand{\dawuhao}{\fontsize{12pt}{18pt}\selectfont}            % 小四, 1.5倍行距
\newcommand{\wuhao}{\fontsize{11pt}{11pt}\selectfont}       % 大五号, 单倍行距
%-------------------------章节名----------------
\usepackage{ctexcap} 
\CTEXsetup[name={,、},number={ \chinese{section}}]{section}
\CTEXsetup[name={（,）},number={\chinese{subsection}}]{subsection}
\CTEXsetup[name={,.},number={\arabic{subsubsection}}]{subsubsection}
%-------------------------页眉页脚--------------
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\kaishu \leftmark}
% \chead{}
\rhead{\kaishu 计算机系统设计实验报告}%加粗\bfseries 
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\renewcommand{\headrulewidth}{0.1pt}  
\renewcommand{\footrulewidth}{0pt}%去掉横线
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}%标题横线
\newcommand{\HRulegrossa}{\rule{\linewidth}{1.2mm}}
%-----------------------伪代码------------------
\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\floatname{algorithm}{Algorithm}  
\renewcommand{\algorithmicrequire}{\textbf{Input:}}  
\renewcommand{\algorithmicensure}{\textbf{Output:}} 
\usepackage{lipsum}  
\makeatletter
\newenvironment{breakablealgorithm}
  {% \begin{breakablealgorithm}
  \begin{center}
     \refstepcounter{algorithm}% New algorithm
     \hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
     \renewcommand{\caption}[2][\relax]{% Make a new \caption
      {\raggedright\textbf{\ALG@name~\thealgorithm} ##2\par}%
      \ifx\relax##1\relax % #1 is \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
      \else % #1 is not \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
      \fi
      \kern2pt\hrule\kern2pt
     }
  }{% \end{breakablealgorithm}
     \kern2pt\hrule\relax% \@fs@post for \@fs@ruled
  \end{center}
  }
\makeatother
%------------------------代码-------------------
\usepackage{xcolor} 
\usepackage{listings} 
\lstset{ 
breaklines,%自动换行
basicstyle=\small,
escapeinside=``,
keywordstyle=\color{ blue!70} \bfseries,
commentstyle=\color{red!50!green!50!blue!50},% 
stringstyle=\ttfamily,% 
extendedchars=false,% 
linewidth=\textwidth,% 
numbers=left,% 
numberstyle=\tiny \color{blue!50},% 
frame=trbl% 
rulesepcolor= \color{ red!20!green!20!blue!20} 
}
%------------超链接----------
\usepackage[colorlinks,linkcolor=black,anchorcolor=blue]{hyperref}
%------------------------TODO-------------------
\usepackage{enumitem,amssymb}
\newlist{todolist}{itemize}{2}
\setlist[todolist]{label=$\square$}
% for check symbol 
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\done}{\rlap{$\square$}{\raisebox{2pt}{\large\hspace{1pt}\cmark}}\hspace{-2.5pt}}
\newcommand{\wontfix}{\rlap{$\square$}{\large\hspace{1pt}\xmark}}
%------------------------水印-------------------
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{eso-pic}

\newcommand{\watermark}[3]{\AddToShipoutPictureBG{
\parbox[b][\paperheight]{\paperwidth}{
\vfill%
\centering%
\tikz[remember picture, overlay]%
  \node [rotate = #1, scale = #2] at (current page.center)%
    {\textcolor{gray!80!cyan!30!magenta!30}{#3}};
\vfill}}}

%———————————————————————————————————————————正文———————————————————————————————————————————————
%----------------------------------------------
\begin{document}
\begin{titlepage}
    \begin{center}
    \includegraphics[width=0.8\textwidth]{NKU.png}\\[1cm]    
    \textsc{\Huge \kaishu{\textbf{南\ \ \ \ \ \ 开\ \ \ \ \ \ 大\ \ \ \ \ \ 学}} }\\[0.9cm]
    \HRule \\[0.9cm]
    { \LARGE \bfseries ShouChun OS设计文档}\\[0.4cm]
    \HRule \\[2.0cm]
    \centering
    \textsc{\LARGE \kaishu{\ \ 队伍名称：寿春队}}\\[0.5cm]
    \textsc{\LARGE \kaishu{\ \ 队伍成员：林坤\quad 邹先宇\quad 郑博月}}\\[0.5cm]
    \textsc{\LARGE \kaishu{\ \ 指导老师：宫晓利\quad 张金}}\\[0.5cm]
    \vfill
    {\Large \today}
    \end{center}
\end{titlepage}
%----------------------------------------------------------------
% 目录
\tableofcontents
%----------------------------------------------------------------
\newpage

【文档情况】

前文尚未核对

正在写内存管理最后部分（但内存管理优化方法暂时没想好怎么写），
到7.28上午预计大致完成文件系统部分

而后根据系统实现写OS设计小节

最后核对文档内容作图

\newpage
\watermark{60}{10}{NKU}
\setcounter{page}{1}

\section{概述}

ShouChun OS是面向2022全国大学生计算机系统能力大赛操作系统设计赛（https://os.edu
cg.net/2022CSCC）的比赛要求进行设计与实现的，该系统为使用C语言进行实现、基于RISCV的多核操作系统，可运行在QEMU（RISCV64 System）
模拟器以及HiFive Unmatched开发板上。

在比赛之前，小队成员系统学习分析了清华大学的uCore教学实验，并进行了操作系统相关知识的学习。
结合比赛要求与团队能力情况，我们决定将清华大学陶天骅手下的uCore-SMP（https://github.com/TianhuaTao/uCore-SMP）
移植到HiFive Unmatched开发板上，并且在此基础上进行完善与改进。

uCore-SMP是一个基于riscv64的操作系统内核，支持多处理器工作，十分符合比赛方所要求的开发板条件。同时
uCore-SMP主要使用了C语言进行开发，更易上手，于是项目小组选择了uCore-SMP作为基础进行开发。

\subsection{项目背景及意义}

操作系统作为计算机系统的管家，为用户程序提供了一个简单清晰的计算机模型。由于操作系统所管理的计算机系统较为复杂，
但又对于理解计算机运行原理来说至关重要，所以在本科教学过程中，操作系统是一个困难而重要的学科。

南开大学十分重视操作系统知识的教授，故十分鼓励学生进行课程知识学习之外的拓展与实践。
本科学习阶段注重于基本理论知识的学习，为利于学生形成一个更为系统清晰的知识体系，且加以课时限制的原因，
操作系统课程停留在单核操作系统阶段。
然而，现代计算机硬件技术发展飞速，多核以及异构架构的硬件日新月异，操作系统作为
软件运行中重要的一环也需要不断更新拓展。

因此，理论知识也应当不断更新，与时俱进，课程之外的学习实践十分重要。
以赛促学，于是项目小组决定在参加操作系统大赛的过程中不断学习，
拓展理论知识，并通过编程实践提高动手能力和计算机系统设计能力，锻炼自身解决复杂工程问题的能力。


\subsection{国内外研究现状}

\subsection{项目工作概述}

该项目的开发均基于uCore-SMP。uCore-SMP为一个基于RISCV的操作系统内核，支持多处理器。项目大量引用
了MIT的xv6(https://github.com/mit-pdos/xv6-riscv)，但是具有许多不同之处。相比于xv6，uCore-SMP
具有不同的系统调用、不同的内存布局、不同的代码风格等等，此外uCore-SMP使用了一个SBI来做硬件的抽象化。
经过学习后，项目组将其与比赛要求进行了比较，发现需要实现更多的系统调用，调整文件、进程、内存管理等等，
从而将其应用于不同于原K210开发板的HiFive Unmatched开发板上，实现比赛需求的功能。

\subsubsection{实现功能}

本项目主要是面对操作系统大赛的要求进行开发的，比赛要求实现需要实现的功能如下：

\begin{itemize}
  \item 启动和系统初始化
  \item 内存管理
  \item 进程管理和中断异常机制
  \item 系统调用
  \item FAT32文件系统
  \item 命令解释程序
\end{itemize}

\subsubsection{开发环境}

项目开发过程中使用的硬件模拟器为QEMU。本项目选择的硬件实验设备为HiFive Unmatched开发板，其主要参数如下：

（1） CPU: 64位SiFive FU740 SoC，集成四个1.5GHz U74-MC 内核 + 一个 S7 嵌入式内核

（2）内存：16GB DDR4 RAM

（3）板载32MB SPI闪存芯片，提供了 4×USB 3.2 Gen 1 端口、一个 PCI Express x16 插槽（x8 速率）、
一个 NVME M.2 插槽、microSD 读卡器、以及千兆以太网

\section{任务分析总结}

本项目开发所基于的uCore-SMP是基于MIT的xv6进一步实现的、支持多核的操作系统。但是其原支持硬件平台为K210开发板，
且只实现了部分系统调用。为成功移植uCore-SMP到HiFive Unmatched开发板，并且实现比赛所要求实现的功能，需要对原代码
进行修改调整。从比赛要求所需要的系统调用出发进行需求的分析总结，总的来说需要的工作为：

\begin{itemize}
  \item 实现SD卡驱动
  \item 参照Linux操作系统进行FAT32文件系统的移植
  \item 调整文件管理结构
  \item 实现加载文件使用的loader
  \item 实现系统调用，根据要求调整内存、进程和文件相关代码
  \item 实现静态链接与动态链接
\end{itemize}

按照比赛所设定的阶段，任务也可以按照阶段进行划分，具体表现为不同阶段实现的系统调用：

\subsection{初赛阶段}

经任务分析和编程实现，初赛阶段完成的系统调用及调用号宏定义如下（比赛要求中的39及40系统调用尚未实现）：

\begin{lstlisting}[title=实现的系统调用及其系统调用号,frame=trbl,language={C}]
  #define SYS_getcwd 17
  #define SYS_dup 23
  #define SYS_dup3 24
  #define SYS_mknod 33
  #define SYS_mkdirat 34
  #define SYS_unlinkat 35
  #define SYS_linkat 37
  #define SYS_umount2 39//TODO
  #define SYS_mount 40//TODO
  #define SYS_chdir 49
  #define SYS_openat 56
  #define SYS_close 57
  #define SYS_pipe2 59
  #define SYS_getdents64 61
  #define SYS_read 63
  #define SYS_write 64
  #define SYS_fstat 80
  #define SYS_exit 93
  #define SYS_waitpid 95
  #define SYS_sched_yield 124
  #define SYS_kill 129
  #define SYS_setpriority 140
  #define SYS_getpriority 141
  #define SYS_times 153
  #define SYS_uname 160
  #define SYS_gettimeofday 169
  #define SYS_settimeofday 170
  #define SYS_getpid 172
  #define SYS_getppid 173
  #define SYS_sysinfo 179
  #define SYS_brk 214
  #define SYS_munmap 215
  #define SYS_clone 220
  #define SYS_execve 221
  #define SYS_mmap 222
  #define SYS_wait4 260
  #define SYS_execv 281
  #define SYS_sharedmem 282
  #define SYS_spawn 400
  #define SYS_mailread 401
  #define SYS_mailwrite 402
\end{lstlisting}

\subsection{决赛阶段}

决赛使用了musl和libc-test作为赛题，需要额外实现动态链接的功能。这需要我们
继续对系统调用进行完善。


\section{系统框架设计}

\subsection{整体框架}

ShouChun OS的设计框架图如下所示：

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.15]{image/img01.png}
\end{figure}

ShouChun OS实现框架设计具有模块化的特点，这一点正是对应RISCV架构的特点实现的。
RISCV不同模块组织在一起，成为统一架构，用户可灵活选择模块组合应对不同的应用场景。
对于本项目中较为复杂的操作系统场景而言，同时应用了MachineMode（机器模式）和UserMode（用户模式）。
对应这样的模块组合，操作系统工作的大致流程即：用户应用程序通过库函数（静态或动态链接）来发起系统调用请求，
从而实现自身特权级无法完成的操作，内核层作为高特权级在更为安全的情况下完成对应请求。请求的具体实现是通过
硬件接口使用HiFive Unmatched开发板实现的，其中还需要驱动SD卡。
接下来对框架中每一个模块的大致功能实现进行阐述。

HiFive Unmatched开发板与SBI（硬件接口）。HiFive Unmatched开发板具体情况在前文已提及，不作赘述。开发板是具体实现所使用的
硬件实现对于操作系统开发者而言并非擅长之处。为了方便开发者工作，SBI（Supervisor Binary Interface）发挥
了较大的作用。SBI在规定的行业标准下将硬件抽象化，为开发者提供了便捷使用硬件的接口，从而减少了开发者的工作量，又
很好的实现了模块化，使得不同部分的移植更为便捷。ShouChun OS所使用的RISCV运行规范为OpenSBI。

项目工作主要集中在内核部分，为了方便项目开发与文档理解，项目将内核部分的设计大致分为三个部分：进程管理、内存管理和文件系统。在成功启动内核后，
三个部分协同工作，完成用户应用程序所要求的功能。其中进程管理主要负责用户进程创建、删除、切换等工作，实现进程部分对用户进程相关请求的相应。内存
管理部分实现内存的分配、释放功能，其中包含有页表相关功能以及堆栈的管理。关于文件系统部分，项目按照比赛要求实现了FAT32格式文件系统，此外还实现了
SD卡驱动的功能。比赛要求使用SD卡读取烧写好的测试文件进行测试。驱动SD卡功能需要文件系统和SPI共同实现，文件系统模块概念稍后再做详细介绍。SPI
（Serial Peripheral Interface）是一种高速的、全双工的、同步的通信总线，它遵从主-从模式的控制方式，由主设备来控制次设备，为开发者提供
接口来方实现外设功能。最终实现了能够对硬盘进行驱动、初始化、读取和写入的功能。FAT32文件系统对于文件实现了抽象化、规范化，使得内核能够更加清晰便捷地管理文件。

内核实现的这些工作使得用户程序能够间接实现更高权限的操作，同时又更加具备安全性。这一过程是通过系统调用实现的：用户应用程序通过API层的库函数来
执行所需功能，库函数可以发起系统调用，通过数据的传递等发起系统调用请求，从而发起中断使操作系统内核执行相关操作并作出响应。



\subsection{内核模块设计}
项目组的工作主要在于内核部分，故接下来针对内核部分的三大模块：进程管理、内存管理、文件系统进行设计展示。
\subsubsection{进程管理}


\subsubsection{内存管理}
\subsubsection{文件系统}


\section{具体实现}

ShouChun OS主要使用C语言实现，其基于的框架为清华大学陶天骅的uCore-SMP。

\subsection{内核的启动}

内核运行平台为HiFive Unmatched 开发板，其继承了多个内核。其启动过程入下：

【QEMU?】
首先是使用一个python脚本（scripts/kernelld.py）编写内核加载脚本，其中指定了内核
的入口为0x8020000，另外规定了存储布局情况，将用户应用程序的文件名称也写入相应位置【存疑，商议修改】。
在执行完该脚本后，就会得到kernel\_app.ld用于内核的加载。而后会运行scripts/pack.py来
生成链接脚本，该程序用于将用户程序链接打包。

内核加载脚本中指定的入口地址0x80200000即为内核镜像的加载地址，在内核镜像加载完成时即跳转到该入口点处
执行相应内容。我们可以通过汇编文件entry.S来观察这个入口点：

\begin{lstlisting}[title=内核镜像入口,frame=trbl,language={C}]
  .section .text.entry
  .globl _entry
_entry:
  # a0: hartid
  # every core has a boot stack of 4 KB
  la sp, boot_stack
  li t1, 1024*4   # t1 = 4KB
  addi t0, a0, 1  # t0 = hartid + 1
  mul t0, t0, t1  # 4K * (hartid + 1)
  add sp, sp, t0  
  call main

  .section .bss.stack
  .globl boot_stack
  .globl boot_stack_top
boot_stack:
  .space 1024 * 4 * 8
  .globl boot_stack_top
boot_stack_top:
\end{lstlisting}

该汇编文件具体功能即为给当前核分配一个大小为4KB的内核栈空间，
并且将内核栈的地址存储到sp寄存器中，最终调用main()函数启动内核。
在多核系统中，每一个核都会执行该段代码，获取自身的内核栈空间，使得
不同核运行在不同的位置处（这一位置是与内核编号相关的），互不影响，并行工作。

在跳转到main函数后，会进行操作系统的初始化等操作。此时尚未成功在
FU740上成功启动多核。项目具体的实现方法为：在完成初始化操作后，由当前
启动的核来启动其他核，用于启动其他核的核为第一次启动。启动是通过SBI接口来实现
的，需要传参所需启动核的编号。以下为具体启动核的SBI接口函数：

\begin{lstlisting}[title=内核镜像入口,frame=trbl,language={C}]
void start_hart(uint64 hartid,uint64 start_addr, uint64 a1) {
    a_sbi_ecall(0x48534D, 0, hartid, start_addr, a1, 0, 0, 0);
}
\end{lstlisting}

启动内核使用的main函数大致如下（省略信息展示与初始化部分）。

\begin{lstlisting}[title=内核启动的main函数,frame=trbl,language={C}]
  void main(uint64 hartid, uint64 a1) {
    if (first_hart) {
      // 计算机信息展示...
      // 初始化工作...
        if (hartid >= NCPU){
            panic("unexpected hartid");
        }
        int CPU_START=1;    // core 0 is not usable
        for (int i = CPU_START; i < NCPU; i++) {
            if (i != hartid && i!=0) // not this hart
            {
                printf("[ucore] start hart %d\n", i);
                start_hart(i, (uint64)_entry, 0);
                while (booted[i] == 0){
                    // wait
                }
            }
        }
        wait_all_boot();
    } else {
        hart_bootcamp(hartid, a1);
    }
    while (!all_started) {
        ; // wait until all hard started
    }
    // 内核运行
}
  \end{lstlisting}

可以看到，当前启动核为第一次启动时，就会用于遍历启动其他所有核；当判断到当前核并非初次
启动时，就说明无需帮忙其他核，初始化与其他核的独立部分即可。等待所有核启动后，各个核
再进入运行状态。需要注意的是，FU740具有四个大核以及一个小核，小核并不能通过SBI
启动，所以启动时内核编号需要从1开始。
\subsection{进程管理与中断异常机制}

进程管理的实现主要是通过核心的结构体proc实现的。通过结合proc结构体和
一些关键函数，实现了操作系统管理进程的功能。

\subsubsection{核心结构体proc}

进程管理的核心结构体为proc，其定义如下：

\begin{lstlisting}[title=proc结构体,frame=trbl,language={C}]
  struct proc {
    struct spinlock lock;

    // PUBLIC: p->lock must be held when using these:
    enum procstate state;  // Process state
    int pid;               // Process ID
    int killed;            // If non-zero, have been killed
    pagetable_t pagetable; // User page table
    void *waiting_target;  // used by sleep and wakeup, a pointer of anything
    uint64 exit_code;      // Exit status to be returned to parent's wait

    // proc_tree_lock must be held when using this:
    struct proc *parent; // Parent process

    // PRIVATE: these are private to the process, so p->lock need not be held.
    uint64 ustack_bottom;        // Virtual address of user stack
    uint64 kstack;               // Virtual address of kernel stack
    struct trapframe *trapframe; // data page for trampoline.S, physical address
    struct context context;      // swtch() here to run process
    uint64 total_size;           // total memory used by this process
    uint64 heap_start;           // start of heap
    uint64 heap_sz;
    uint64 stride;
    uint64 priority;
    uint64 user_time;           // us, user only
    uint64 kernel_time;         // us, kernel only
    uint64 last_start_time;     // us
    struct file *files[FD_MAX]; // Opened files
    struct inode *cwd;          // Current directory
    struct shared_mem * shmem[MAX_PROC_SHARED_MEM_INSTANCE];
    void * shmem_map_start[MAX_PROC_SHARED_MEM_INSTANCE];
    void* next_shmem_addr;
    struct mapping maps[MAX_MAPPING];
    char name[PROC_NAME_MAX]; // Process name (debugging)
};
  \end{lstlisting}

进程管理相关的操作大部分都是基于此结构体进行实现的。proc结构体
的成员从性质封面来看，大致可以分为公开资源和私有资源两个部分，可用以更加方便地实现
多进程安全并行；从功能方面来看，proc成员分为四类：进程的基本信息、
进程的内存信息、进程文件信息和其他信息。

进程的基本信息包括了进程编号、进程上下文、父进程等。其中state为进程的状态，
包括有UNUSED、USED、SLEEPING、RUNNABLE、RUNNING、ZOMBIE六种情况，利用
这几种状态就可以实现进程的调度和回收等功能；pid为进程编号，是进程
重要的成员属性，大多进程管理相关操作都基于此实现；parent记录了父进程，用于
进程之间关系的管理；context记录了进程的上下文，用于进程的切换；trapframe陷阱帧
用于异常中断机制的运行现场恢复；exit\_code用于
在子进程退出时将退出状态码放回给父进程。

进程的内存信息包括进程占用的地址空间、堆以及共享内存信息。ustack\_bottom、kstack、
heap\_start分别记录了用户栈、内核栈、堆的地址，这里的地址指虚拟地址；shmem\_map\_start
和next\_shmem\_addr记录了共享内存相关的信息，共享内存使得多个进程能够更加便捷地进行沟通，
共享内存使用map来记录所使用物理页的情况；pagetable记录了当前进程所使用
的页表，从而进行虚拟地址和物理地址之间的转换。

进程的文件信息包括了文件描述符数组和当前位于目录。files记录了所有已经打开的文件描述符；cwd可
获取当前所处的目录。

其他信息包含了运行时间、信号、优先级、调度权等，辅助进行进程的管理。结构体中的成员lock用于实现进程锁，从而达成多进程并行执行而互不影响。进程锁的使用
对进程公开资源的修改来说十分重要。

\subsubsection{进程管理函数}

一个核可以同时运行多个进程，内核使用了进程池来对进程进行管理。结合proc结构、pool进程池和其他一些重要辅助信息，
可以完成进程的创建、销毁、调度和调度等功能。

（1）进程的创建与销毁：在创建进程时，会在进程池中找到一个可用的进程号（pid），进行初始化。proc唯一对应一个
进程，创建时将根据程序内容构建处用户地址空间并分配物理空间。当进程退出时，需要对进程进行销毁，释放其占用的进程池
中的可用pid，并重新初始化结构体。

（2）进程调度方法：进程的调度使用 Stride算法。该种算法为不同的进程分配了不同的优先级，每个进程得到的时间资源
预期优先级成正比。以下是调度所使用的代码（只列出了调度相关的核心部分）：

\begin{lstlisting}[title=进程调度方法,frame=trbl,language={C}]
void scheduler(void)
{
    // ...
    for (;;){
        uint64 min_stride = ~0ULL;
        struct proc *next_proc = NULL;
        int any_proc = FALSE;

        for (struct proc *p = pool; p < &pool[NPROC]; p++){
            if (!p->state == UNUSED){
                any_proc = TRUE;
                // debugcore("state=%d", p->state);
            }
            if (p->state == RUNNABLE && !p->lock.locked){
                if (p->stride < min_stride){
                  //找到stride最小的进程
                    min_stride = p->stride;
                    next_proc = p;
                }
            }
        }
      // ...
        if (next_proc != NULL)
        {
            //...
            //计算步长pass并更新stride
            uint64 pass = BIGSTRIDE / (next_proc->priority);
            next_proc->stride += pass;
            //进行进程的切换
            swtch(&mycpu()->context, &next_proc->context);
            //...
        }
        else{
          //...
        }
       //...
    }
}
  \end{lstlisting}

算法基本思想为：

1.为处于RUNNABLE状态的进程设置优先级，表示进程当前的调度权。并定义pass值，表示
相应进程在调度后，stride需要累加的值。

2.在每次需要调度时，从当前RUNNABLE状态的进程中选择stride最小的进程进行调度。

3.获得调度的进程，将其stride加上对应的步长pass（pass值只与进程的优先权有关）。

4.在一段固定时间后，回到步骤2，重新进行调度，运行当前进程池中stride最小（非0）的进程。

其中，调度进程时的切换过程为：首先保存当前进程的上下文（context），而后再通过所需调度进程的上下文恢复所需调度进程
的现场，从而实现调度。具体内容在汇编文件switch.S中。

（4）创建子进程：创建子进程实际也是实现fork的方法，在执行fork操作时，当前进程，即父进程，会构造一个
与自己完全相同的用户空间，并分配对应的空间、pid以及内核栈，新得到的进程即为子进程。

【文字描述】
【子模块的具体实现，关键的函数、结构体以及优化】
\subsubsection{中断异常机制}

中断机制在系统中起着通信网络的作用，可以协调系统对各种外部事件的响应和处理。
中断是CPU 对系统发生的某个事件作出的一种反应。引起中断的事件称为中断源。
中断源向CPU 提出处理的请求称为中断请求。发生中断时被打断程序的暂停点称为断点。
CPU暂停现行程序而转为响应中断请求的过程称为中断响应。处理中断源的程序称为中断处理程序。
CPU执行有关的中断处理程序称为中断处理。



\subsubsection{中断处理}

中断处理所使用的到结构体为trapframe：

\begin{lstlisting}[title=trapframe结构体,frame=trbl,language={C}]
  struct trapframe {
    /*   0 */ uint64 kernel_satp;   // kernel page table
    /*   8 */ uint64 kernel_sp;     // top of process's kernel stack
    /*  16 */ uint64 kernel_trap;   // usertrap()
    /*  24 */ uint64 epc;           // saved user program counter
    /*  32 */ uint64 kernel_hartid; // saved kernel tp
    // ...... 寄存器
    /* 280 */ uint64 t6;
};
  \end{lstlisting}

trapframe中主要内容为发生中断异常时的现场情况，其中kernel\_satp给出了内核页表的地址；
kernel\_sp指向了进程内核栈的顶部；kernel\_trap指向usertrap函数，用于在用户状态下发生
中断时跳转到处理函数。

用户状态下中断处理流程图如下：

【作图】
【存疑】

中断的处理需要使用的函数为usertrap，在trap.c文件中。每次出现中断或者异常时，都需要跳转到中断入口处，
执行trampoline.S汇编代码的内容，即先保存当前用户程序的现场到trapframe当中，最后取出kernel\_trap中
所存储的usertrap函数的地址，最终跳转到该函数处进行中断的处理。在usertrap中，会首先将kernelvec的地址写入
stvec中，作为中断处理的基址，此时的中断为需要升高权限为内核态所处理的中断了。usertrap处理
中断时，分为了中断和异常两种情况。其中中断包括有计时器发起的中断和外部设备发起的中断；异常包含了指令异常和页
加载异常等等，本项目中心工作所集中的系统调用便包含在异常当中，具体处理异常的代码如下：

\begin{lstlisting}[title=系统调用异常,frame=trbl,language={C}]
  case UserEnvCall:   // 8
  if (p->killed)
      exit(-1);
  trapframe->epc += 4;
  intr_on();
  syscall();
  break;
  \end{lstlisting}

在用户态发起系统调用异常后，会使用syscall函数作为接口，读取trapframe中所记录的系统调用号
以及参数，从而在syscall函数中找到对应的中断处理函数。将参数传给相应的中断处理函数并执行结束后，
将返回值存储在trapframe的a0中，最终返回时会通过存储的地址返回调用位置，恢复触发中断前的现场。
本项目中内核态下的中断主要是时钟中断与外部中断，其他情况下的中断与异常均作为意外情况，使用panic
退出程序。

\subsection{内存管理}

内存管理部分的实现主要包括用户地址空间以及内核地址空间。

\subsubsection{内核地址空间}

初次加载内核操作系统时，内核地址空间需要载入启动所需数据，并通过makeshellproc函数来创建第一个
进程，加载用户驱动程序从而实现与用户进行交互。在多进程运行过程中，内核地址空间被划分为了多个内核栈空间，
对应不同的进程：

【无Guard Page？】

【内核地址空间示意图】

每个进程对应着自己唯一的内核栈。当新建一个进程时，都需要为其分配内核栈空间。以下是新建进程时给进程分配内核栈的代码：

\begin{lstlisting}[title=分配内核栈空间,frame=trbl,language={C}]
struct proc *alloc_proc(void) {
    // ......
    memset(&p->context, 0, sizeof(p->context));
    p->kstack = (uint64)kstack[p - pool];
    memset((void *)p->kstack, 0, KSTACK_SIZE);

    p->context.ra = (uint64)forkret; // used in swtch()
    p->context.sp = p->kstack + KSTACK_SIZE;
    // ......
}
\end{lstlisting}

可以看到，内核栈空间的分配方法为从划分好的内核栈分配中，选取对应进程池中位置的
内核栈。也就是说，每个进程对应着进程池中唯一的一个proc指针，每一个proc都对应着固定
的内核栈地址。内核栈设置使用的方法为定义NPROC×KSTACK\_SIZE大小的二位字符数组，
即最多可同时给NPROC（256）个进程分配内核栈，且内核栈大小为KSTACK\_SIZE（8192），【由于分配的
内核栈大小足够大，故未使用guardpage分隔内核栈】

\subsubsection{用户地址空间}

下图是用户地址空间示意图。

本项目使用了SV39虚拟内存，支持高达256GB的用户内存空间。文本段从0x1000开始，堆栈底部位于
3GB处。用户空间的顶部为trampoline，将虚地址和实地址对应了起来，可用于在多进程并行时切换进程。在
Trampoline下存储着TrapContext用于恢复存储用户进程的上下文。在堆栈底部，是为进程预先分配好的
内存空间，包括数据段、代码段等等。用户地址空间中，堆空间作为动态分配的空间从堆栈底部向高地址增长，
栈空间从TrapContext底部向低地址增长。不过这里这一部分的内容都是使用共享内存实现的，共享内存块
之间都使用了GuardPage来分隔。虚拟地址的管理使用了页表机制，进程在访问到记录好的页表的物理地址后，可以通过页表
转换找到虚拟地址所对应的物理地址。具体而言，建立虚拟地址和物理地址之间的关系是通过map函数进行实现的。

这些用户地址信息记录在进程管理结构体proc当中（见进程管理一节），可以访问进行内存的管理，也可以修改来改变内存的布局。
brk系统调用即为扩充堆的大小，实现动态分配内存。


\subsubsection{Shared Memory}

共享内存是多个进程相互通信的简单方法。用户可以创建一个具有名称和大小的共享内存，其他人也可以使用这个名称。共享内存
会引用相同的物理页面，最终被映射到自己的虚拟内存空间当中。以下是共享内存的示意图：

【作图】

共享内存使用结构体shared\_mem来进行管理：

\begin{lstlisting}[title=shared\_mem结构体,frame=trbl,language={C}]
struct shared_mem{
  char name[MAX_SHARED_NAME];
  int used;
  int ref;
  int page_cnt;
  void* mem_pages[MAX_SHARED_MEM_PAGE];
};
\end{lstlisting}

其中name为用户为共享内存块创建的名字；used记录了共享内存的使用情况；
ref记录了内存使用的次数，当使用次数减为0时，就需要释放该共享内存块
所指向的物理内存部分了。

需要注意的是，目前除了进程退出无法释放共享内存，内核会根据需要来回收这些页面。

\subsubsection{内存管理函数}
\subsubsection{mmap和munmap}
\subsubsection{内存管理优化方法}



\subsection{文件系统}



\subsubsection{关键结构体}
\subsubsection{关键函数}


\section{测试结果}

\section{总结与感悟}

\subsection{工作实现总结}

\subsection{最终感悟}

\end{document}
